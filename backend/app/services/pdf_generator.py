"""
PDF Report Generator using Playwright.

Generates professional PDF reports from audit data using HTML templates
rendered with Playwright's headless Chromium browser.
"""

import logging
from datetime import datetime
from pathlib import Path
from typing import Any, Optional

from jinja2 import Environment, FileSystemLoader

from app.config import settings
from app.services.seo_recommendations import get_detailed_recommendation

logger = logging.getLogger(__name__)


class PDFGenerator:
    """Generate PDF reports from HTML templates using Playwright."""

    def __init__(self):
        """Initialize the PDF generator with templates."""
        template_dir = Path(__file__).parent / "templates" / "pdf"
        self.env = Environment(
            loader=FileSystemLoader(template_dir),
            autoescape=True,
        )
        self._styles = self._load_styles()

    def _load_styles(self) -> str:
        """Load CSS styles from file."""
        style_path = Path(__file__).parent / "templates" / "pdf" / "styles.css"
        if style_path.exists():
            return style_path.read_text()
        logger.warning("PDF styles.css not found, using minimal styles")
        return """
            body { font-family: Arial, sans-serif; font-size: 11pt; }
            h1 { color: #1e40af; }
            h2 { color: #2563eb; }
            table { width: 100%; border-collapse: collapse; }
            th, td { border: 1px solid #ddd; padding: 8px; }
        """

    async def generate_audit_pdf(
        self,
        audit_data: dict[str, Any],
        issues: list[dict[str, Any]],
        site_url: str,
        score: int,
        logo_url: Optional[str] = None,
        brand_color: str = "#2563eb",
        include_code_examples: bool = True,
        max_urls_per_issue: int = 10,
    ) -> bytes:
        """
        Generate PDF from audit data.

        Args:
            audit_data: Audit metadata (generated_at, checks_run, etc.)
            issues: List of issue dictionaries
            site_url: The site URL being audited
            score: Overall audit score (0-100)
            logo_url: Optional logo URL for white-labeling
            brand_color: Primary brand color (hex)
            include_code_examples: Whether to include code fix examples
            max_urls_per_issue: Maximum affected URLs to show per issue

        Returns:
            PDF file as bytes
        """
        # Render audit content to HTML
        html_content = self._render_audit_html(
            audit_data=audit_data,
            issues=issues,
            score=score,
            include_code_examples=include_code_examples,
            max_urls_per_issue=max_urls_per_issue,
        )

        # Get the base template
        template = self.env.get_template("base.html")

        # Apply brand color to styles
        styles = self._styles.replace("#2563eb", brand_color)

        # Generate timestamp
        generated_at = audit_data.get(
            "generated_at",
            datetime.utcnow().strftime("%Y-%m-%d %H:%M UTC"),
        )

        # Render full HTML document
        full_html = template.render(
            title=f"SEO Audit Report",
            subtitle=site_url,
            generated_at=generated_at,
            logo_url=logo_url,
            content=html_content,
            styles=styles,
            footer_text="Generated by SEOman",
        )

        # Generate PDF using Playwright
        return await self._html_to_pdf(full_html)

    def _render_audit_html(
        self,
        audit_data: dict[str, Any],
        issues: list[dict[str, Any]],
        score: int,
        include_code_examples: bool = True,
        max_urls_per_issue: int = 10,
    ) -> str:
        """Convert audit data to styled HTML content."""
        html_parts = []

        # Score section
        score_class = "good" if score >= 80 else "fair" if score >= 60 else "poor"
        score_label = "Excellent" if score >= 80 else "Needs Work" if score >= 60 else "Poor"

        html_parts.append(f'''
        <div class="score-section">
            <span class="score-badge score-{score_class}">{score}/100</span>
            <span class="score-label">{score_label}</span>
        </div>
        ''')

        # Summary stats
        checks_run = audit_data.get("checks_run", 100)
        pages_crawled = audit_data.get("pages_crawled", 0)

        html_parts.append(f'''
        <div class="summary-stats">
            <div class="stat-card">
                <div class="stat-value">{checks_run}</div>
                <div class="stat-label">Checks Run</div>
            </div>
            <div class="stat-card">
                <div class="stat-value">{len(issues)}</div>
                <div class="stat-label">Issues Found</div>
            </div>
            <div class="stat-card">
                <div class="stat-value">{pages_crawled}</div>
                <div class="stat-label">Pages Crawled</div>
            </div>
        </div>
        ''')

        # Executive summary table
        html_parts.append('<h2>Executive Summary</h2>')
        html_parts.append('<table>')
        html_parts.append('<tr><th>Severity</th><th>Count</th><th>Description</th></tr>')

        severity_counts = {"critical": 0, "high": 0, "medium": 0, "low": 0}
        for issue in issues:
            sev = issue.get("severity", "low").lower()
            if sev in severity_counts:
                severity_counts[sev] += 1

        severity_descriptions = {
            "critical": "Issues blocking indexing or causing severe problems",
            "high": "Significant issues affecting rankings and user experience",
            "medium": "Important issues that should be addressed",
            "low": "Minor improvements and best practices",
        }

        for sev, count in severity_counts.items():
            if count > 0:
                html_parts.append(
                    f'<tr>'
                    f'<td><span class="severity-badge badge-{sev}">{sev.title()}</span></td>'
                    f'<td>{count}</td>'
                    f'<td>{severity_descriptions[sev]}</td>'
                    f'</tr>'
                )

        html_parts.append('</table>')

        # Issues by severity
        for severity in ["critical", "high", "medium", "low"]:
            sev_issues = [i for i in issues if i.get("severity", "").lower() == severity]
            if not sev_issues:
                continue

            html_parts.append(f'<h2 class="page-break">{severity.title()} Priority Issues ({len(sev_issues)})</h2>')

            for idx, issue in enumerate(sev_issues, 1):
                title = issue.get("title", issue.get("check_name", "Unknown Issue"))
                category = issue.get("category", "General")
                affected_urls = issue.get("affected_urls", [])
                details = issue.get("details", {})

                # Get detailed recommendation
                detailed_rec = get_detailed_recommendation(title, details)

                html_parts.append(f'''
                <div class="issue-card no-break">
                    <h3>
                        <span class="severity-badge badge-{severity}">{severity.title()}</span>
                        {idx}. {title}
                    </h3>
                    <div class="issue-meta">
                        <span><strong>Category:</strong> {category}</span>
                        <span><strong>Affected:</strong> {len(affected_urls)} page(s)</span>
                    </div>
                ''')

                # Description
                description = detailed_rec.get("description") or issue.get("description", "")
                if description:
                    html_parts.append(f'<p>{description}</p>')

                # Why it matters
                if detailed_rec.get("why_it_matters"):
                    html_parts.append(f'''
                    <div class="why-matters">
                        <strong>Why it matters:</strong> {detailed_rec["why_it_matters"]}
                    </div>
                    ''')

                # How to fix
                how_to_fix = detailed_rec.get("how_to_fix") or issue.get("recommendation", "")
                if how_to_fix:
                    html_parts.append(f'''
                    <div class="how-to-fix">
                        <strong>How to fix:</strong> {how_to_fix}
                    </div>
                    ''')

                # Code example (if enabled and available)
                if include_code_examples and detailed_rec.get("code_example"):
                    # Extract just the first code block to keep PDFs manageable
                    code_example = detailed_rec["code_example"]
                    # Limit code example length for PDF
                    if len(code_example) > 1500:
                        code_example = code_example[:1500] + "\n... (truncated)"
                    html_parts.append(f'<p><strong>Example:</strong></p>')
                    html_parts.append(f'<pre><code>{self._escape_html(code_example)}</code></pre>')

                # Affected URLs
                if affected_urls:
                    html_parts.append('<div class="affected-urls">')
                    html_parts.append('<p><strong>Affected Pages:</strong></p>')
                    html_parts.append('<ul>')
                    for url in affected_urls[:max_urls_per_issue]:
                        html_parts.append(f'<li><code>{self._escape_html(url)}</code></li>')
                    if len(affected_urls) > max_urls_per_issue:
                        html_parts.append(f'<li><em>... and {len(affected_urls) - max_urls_per_issue} more</em></li>')
                    html_parts.append('</ul>')
                    html_parts.append('</div>')

                html_parts.append('</div>')  # Close issue-card

        return '\n'.join(html_parts)

    def _escape_html(self, text: str) -> str:
        """Escape HTML special characters."""
        return (
            text.replace("&", "&amp;")
            .replace("<", "&lt;")
            .replace(">", "&gt;")
            .replace('"', "&quot;")
            .replace("'", "&#39;")
        )

    async def _html_to_pdf(self, html: str) -> bytes:
        """
        Convert HTML to PDF using Playwright.

        Args:
            html: Full HTML document string

        Returns:
            PDF file as bytes
        """
        try:
            from playwright.async_api import async_playwright
        except ImportError:
            logger.error("Playwright not available for PDF generation")
            raise RuntimeError(
                "PDF generation requires Playwright. "
                "Install with: pip install playwright && playwright install chromium"
            )

        async with async_playwright() as p:
            browser = await p.chromium.launch(
                args=["--no-sandbox", "--disable-setuid-sandbox"]
            )
            page = await browser.new_page()

            # Set content and wait for rendering
            await page.set_content(html, wait_until="networkidle")

            # Generate PDF with configured margins
            pdf_bytes = await page.pdf(
                format=settings.PDF_PAGE_SIZE,
                margin={
                    "top": settings.PDF_MARGIN_TOP,
                    "bottom": settings.PDF_MARGIN_BOTTOM,
                    "left": settings.PDF_MARGIN_LEFT,
                    "right": settings.PDF_MARGIN_RIGHT,
                },
                print_background=True,
                display_header_footer=True,
                header_template="<span></span>",
                footer_template='''
                    <div style="font-size:9px; width:100%; text-align:center; color:#9ca3af;">
                        <span class="pageNumber"></span> / <span class="totalPages"></span>
                    </div>
                ''',
            )

            await browser.close()
            return pdf_bytes

    async def generate_plan_pdf(
        self,
        plan_data: dict[str, Any],
        site_url: str,
        logo_url: Optional[str] = None,
        brand_color: str = "#2563eb",
    ) -> bytes:
        """
        Generate PDF from SEO plan data.

        Args:
            plan_data: SEO plan data with phases, tasks, timeline
            site_url: The site URL
            logo_url: Optional logo URL for white-labeling
            brand_color: Primary brand color (hex)

        Returns:
            PDF file as bytes
        """
        html_content = self._render_plan_html(plan_data)

        template = self.env.get_template("base.html")
        styles = self._styles.replace("#2563eb", brand_color)

        full_html = template.render(
            title="SEO Improvement Plan",
            subtitle=site_url,
            generated_at=datetime.utcnow().strftime("%Y-%m-%d %H:%M UTC"),
            logo_url=logo_url,
            content=html_content,
            styles=styles,
            footer_text="Generated by SEOman",
        )

        return await self._html_to_pdf(full_html)

    def _render_plan_html(self, plan_data: dict[str, Any]) -> str:
        """Convert SEO plan data to HTML content."""
        html_parts = []

        # Overview
        html_parts.append('<h2>Plan Overview</h2>')

        phases = plan_data.get("phases", [])
        tasks = plan_data.get("tasks", [])

        html_parts.append(f'''
        <div class="summary-stats">
            <div class="stat-card">
                <div class="stat-value">{len(phases)}</div>
                <div class="stat-label">Phases</div>
            </div>
            <div class="stat-card">
                <div class="stat-value">{len(tasks)}</div>
                <div class="stat-label">Action Items</div>
            </div>
        </div>
        ''')

        # Phases
        for phase in phases:
            phase_name = phase.get("name", "Phase")
            phase_tasks = [t for t in tasks if t.get("phase") == phase.get("id")]

            html_parts.append(f'<h2 class="page-break">{phase_name}</h2>')

            if phase_tasks:
                html_parts.append('<table>')
                html_parts.append('<tr><th>Task</th><th>Priority</th><th>Effort</th></tr>')
                for task in phase_tasks:
                    html_parts.append(
                        f'<tr>'
                        f'<td>{task.get("title", "Task")}</td>'
                        f'<td>{task.get("priority", "medium").title()}</td>'
                        f'<td>{task.get("effort", "medium").title()}</td>'
                        f'</tr>'
                    )
                html_parts.append('</table>')

        return '\n'.join(html_parts)
